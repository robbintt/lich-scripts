=begin
  Documentation:
=end

# common, DRC: check if script is running thingy
# spellmonitor: watch spells
custom_require.call(%w[drinfomon common spellmonitor])

# original from hunting-buddy.lic
#custom_require.call(%w[common common-arcana common-items common-travel drinfomon events spellmonitor equipmanager])

class BuffWatcher

  # from common: have only used one method from DRC so far, not sure what DRCA, DRCI, DRCT are...
  include DRC
  #include DRCA
  #include DRCI
  #include DRCT

  def initialize

    # need to use full name of spell
    @buffs = {'Shadows' => 20,
              'Seer\'s Sense' => 20}

    # track if each camb is linked
    @worn_cambrinth = {'prism' => {'capacity' => 108, 'focused' => false, 'lines' => 0}}

    @active_spells = {}  # init for DRSpells.active_spells

    # what is all this, what can i use
    #arg_definitions = [[]]
    #args = parse_args(arg_definitions, true)
    #@settings = get_settings
    #@stop_on_low_threshold = @settings.stop_on_low_threshold
    #data = get_data('hunting')
    #@escort_zones = data.escort_zones
  end

  def worn_cambrinth
    @worn_cambrinth
  end
  def buffs 
    @buffs
  end

  def nervestate
    if Wounds.nerves > 0
      echo "Wounds: #{Wounds.nerves}"
    else
      echo "No nerve wounds."
    end
  end

  def buff_spellstate(buff)
    active_spells = DRSpells.active_spells
    #echo "spell data: #{active_spells}"
    #echo "Buff '#{buff}' has #{active_spells[buff]} roisaen left."
    return active_spells[buff]
  end

  def cast_buff(spell, mana)
    # dead simple, no dependencies
    # if it doesnt work, the nanny tries again later
    put "prep #{spell} #{mana}"
    pause 16
    fput "cast", "You gesture.", "You"
    waitrt?
  end

  def cambstate(camb, attribs)
    # this doesn't handle cases where skill is not sufficient
    focus = fput "focus #{camb}", "You focus"
    waitrt?
    cambstate_string = matchtimeout 5, "the cambrinth #{camb}"
    lines = /You clearly perceive ([0-9]+) line/.match(cambstate_string)[1]
    # catch empty camb
    unless lines
      lines = 0
    end
    # set focused
    focused = false
    if /Your link to the/.match(cambstate_string)
      focused = true
    end

    # this is extra code, just set it above instead
    echo "Cambrinth has: #{lines} mana."
    @worn_cambrinth[camb]['lines'] = lines.to_i
    echo "Cambrinth is focused: #{focused}"
    @worn_cambrinth[camb]['focused'] = focused
  end

  def prep_camb(camb, target)
    # maybe just specify one worn camb for now? but it is more fun to specify a whole hash/dict of them
    # but then i need some overflow priority...
    # also would be nice to use held camb
    # e.g. worn true/false before operating on the camb, but then i need a hands check

    # a little safety
    unless @worn_cambrinth[camb]
      echo "Cambrinth '#{camb}' not in @worn_cambrinth"
      return
    end
    lines = @worn_cambrinth[camb]['lines']
    if lines > target
      #echo "Amount in cambrinth #{camb} is over the target, skipping cambrinth."
      fput "invoke #{camb} #{target}", "link"
      waitrt?
    elsif target > lines
      fput "charge #{camb} #{target-lines}", "You harness"
      waitrt?
      fput "invoke #{camb}", "link" #fixme
      waitrt?
    else # exact right amount
      fput "invoke #{camb}", "link"
      waitrt? # might not have a roundtime...
    end
  end
end

buffwatcher = BuffWatcher.new

buffwatcher.nervestate

=begin
buffwatcher.worn_cambrinth.each do |camb, attribs|
  buffwatcher.cambstate(camb, attribs)
end
=end

loop {
  # once i figure out how to compare it to something, pass the reset condition as a number - on a per-spell basis
  #   - 0 means reset only after spell wears off, 10 means reset when 10 roisaen left on spell, etc
  buffwatcher.buffs.each do |buff, mana|
    buffstate = buffwatcher.buff_spellstate(buff)

    if !buffstate or buffstate < 5  # 5 minutes is hardcoded temporarily
        buffwatcher.cambstate('prism', @worn_cambrinth['prism'])
        buffwatcher.prep_camb('prism', 5) # get these from elsewhere... how to choose which camb?
        buffwatcher.cast_buff(buff, mana)
    end

    pause 1
  end
}
